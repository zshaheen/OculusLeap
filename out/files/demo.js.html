<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>demo.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: demo.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * demo.js
 * Implementation of 3D immersion mode for the CTIANP project.
 *
 * @author Zeshawn Shaheen edit...
 */


//Three.js variables
var renderer, camera, scene, element;
var ambient, point;
var aspectRatio;
var stats;
var gui, menu;

//Oculus Bridge variables 
var riftCam, oculusBridge;
var bodyAngle, bodyAxis, viewAngle;
var quat, quatCam, xzVector;

//molecules variables
var rightObj, leftObj;
var rightObjLoaded, leftObjLoaded;
var rightTransObj, leftTransObj;
//var rightOrigRotation, leftOrigRotation;

var hydrogenMat = new THREE.MeshLambertMaterial({
	color: 0xFFFFFF // white
});

var oxygenMat = new THREE.MeshLambertMaterial({
	color: 0x0000FF // blue
});

var water_oxygenMat = new THREE.MeshLambertMaterial({
	color: 0xDD3333 // red
});

var carbon_cylinderMat = new THREE.MeshLambertMaterial({
	color: 0x00FF00 // green
});

var defaultMat = new THREE.MeshLambertMaterial( { 
	color: 0xFF33CC //bright pink
});
	

//Leap Variables
var leapController;
var frame;
var rightHand, leftHand;
var rotWorldMatrix;
var yAxis = new THREE.Vector3(0,1,0);
var xAxis = new THREE.Vector3(1,0,0);
	
//Error Dialog variables
var handError, leapError;
var leftLabel, rightLabel;
var interval = 0;

//matrix data
var simMatrix;
var fileName1, fileName2;
var objRawData;
var listFiles; //List of files in a specific directory
var prefix;
var lastHand=&quot;right&quot;, simMatrixRow = 0, simMatrixCol = 1;
var listOfFolders=[], listOfFilesInFolder=[];


window.onload = function() {
	
	init();
	//initLabels();;
	initLeap();
	initErrors();
	initOculus();
	leapLoop();
	var dir = &quot;data&quot;
	ajaxRequestFolders(dir);

	
}

function menu() {
	this.folder = &quot;&quot;;
	this.explode = function() {resetMoleculePos()};
	//this.resetPos = &quot;&quot;;
	//possible for future implementation
	//this.leftMolecule = &quot;&quot;;
	//this.rightMolecule = &quot;&quot;;
}

function ajaxRequestFolders(dir) {
	$.ajax({

		type: &quot;POST&quot;,

		url: &quot;getFilesInDir.php?dir=&quot; + dir + &quot;%2F&quot;,

		dataType: &quot;json&quot;,

		success: function(data) {

			listOfFolders = data.split(&quot;NF&quot;);
			//delete the last index which is just &quot;&quot;
			listOfFolders.splice(listOfFolders.length-1, 1);
			//add a &quot;&quot; in the first index
			listOfFolders.unshift(&quot;&quot;);
			console.log(listOfFolders);
			initMenu();

		}

	});
}

function resetMoleculePos() {
	leftObj.position = new THREE.Vector3(-10,0,-camera.position.z);
	leftTransObj.rotation.set(0,0,0,&#x27;XYZ&#x27;);
	
	rightObj.position = new THREE.Vector3(10,0,-camera.position.z);
	rightTransObj.rotation.set(0,0,0,&#x27;XYZ&#x27;);

	leftObj.rotation.set(0,0,0,&#x27;XYZ&#x27;);
	rightObj.rotation.set(0,0,0,&#x27;XYZ&#x27;);
}


function ajaxRequestFiles(dir) {
	$.ajax({

		type: &quot;POST&quot;,

		url: &quot;getFilesInDir.php?dir=&quot; + dir + &quot;%2F&quot;,

		dataType: &quot;json&quot;,

		success: function(data) {

			//gui.__controllers[2].remove();
			//gui.__controllers[1].remove();

			//console.log(&quot;ajaxRequestFILES success&quot;);
			listOfFilesInFolder = data.split(&quot;NF&quot;);
			//console.log(&quot;data.split working&quot;);
			//delete the last index which is just &quot;&quot;
			listOfFilesInFolder.splice(listOfFilesInFolder.length-1, 1);
			console.log(listOfFilesInFolder);

			//clearTimeout(interval);
			rightLabel.visible = false;
			leftLabel.visible = false;
			simMatrix = [];
			objRawData = [];
			listFiles = [];
			lastHand=&quot;right&quot;;
			simMatrixRow = 0; 
			simMatrixCol = 1;
			resetMoleculePos();
			simReadData();
		}


	});
}


function initMenu() {
	gui = new dat.GUI();
	menu = new menu();
	//gui.add(menu, &quot;folder&quot;, listOfFolders).name(&quot;Choose a folder&quot;).onFinishChange(updateGUI(newValue));
	gui.add(menu, &quot;folder&quot;, listOfFolders).name(&quot;Choose a folder&quot;).onFinishChange(function(newValue){
		if(newValue != &quot;&quot;) {
			prefix = &quot;data/&quot; + newValue +&quot;/&quot;;
			//console.log(&quot;updateGUI called: &quot;+newValue);
			
			ajaxRequestFiles(prefix);
			
		}
	});
	gui.add(menu, &#x27;explode&#x27;).name(&quot;Reset position&quot;);
}

function simReadData() {


	//var dirs; // List of directories. ex: 0x1, 0x2, etc.
	
	var comdata = [];
	var tempData, line;

	
	//dirs = [&quot;0x1&quot;,&quot;0x2&quot;];
	//assuming we opened the folder 0x1
	//listFiles = [&quot;5155&quot;, &quot;6288&quot;, &quot;6465&quot;, &quot;7067&quot;, &quot;7392&quot;, &quot;7861&quot;, &quot;9996&quot;];
	listFiles = listOfFilesInFolder;
	console.log	

	//prefix = &quot;data/&quot; + dirs[0]+&quot;/&quot;;

	//var comdata = [];
	for(var i=0; i&lt;listFiles.length; i++) {
	
		var get = $.get(prefix+listFiles[i], function(data) {
			// split the data by line
			tempData = data.split(&quot;\n&quot;);
			line = tempData[0].split(&quot; &quot;);
			
			comdata.push( [line[1], line[2], line[3]] );
		});
	}
	
	get.success(function() {
		simCreateMatrix(comdata, listFiles.length);
		//console.log(simMatrix[0].sortIndices );
		//set fileName1 and fileName2
		fileName1 = prefix + listFiles[simMatrixRow];
		fileName2 = prefix + listFiles[ simMatrix[simMatrixRow].sortIndices[simMatrixCol] ];
		//The left label is always intially 0
		//
		drawLabels(0, getIndex(listFiles[simMatrix[0].sortIndices[1]]), listFiles.length-1 ,fileName1, fileName2, &quot;right&quot;);
		draw();
			
	});
}

function simCreateMatrix(comdata, size) {
	//console.log(comdata[0]);
	//console.log(comdata[1])
	//console.log(euclideanDistance( comdata[0],comdata[1] ));
	//create the similarity matrix
	/*
	* 
	* 
	* 
	*/
	//Make simMatrix a  2d array
	simMatrix = [];
	var temp1dArray;// = [];
	
	//Can optimize below
	for(var i=0; i&lt;size; i++) {
		temp1dArray = [];
		
		for(var j=0; j&lt;size; j++) {
			//console.log( i.toString() + j.toString() );
			temp1dArray.push(euclideanDistance(comdata[i], comdata[j]));
		}
		simMatrix.push(temp1dArray);
	}
	
	//display the raw euclidean distances in simMatrix
	/*
	for(var i=0; i&lt;size; i++) {
		for(var j=0; j&lt;size; j++) {
			//if(i == 0)
				//console.log(comdata[i] + &quot; &amp; &quot; + comdata[j]);
			console.log( i + &quot;, &quot; + j + &quot;: &quot; + simMatrix[i][j] );
		}
	}
	*/
	
	
	//now sort the arrays based on size, 
	/* Looking in folder 0x1
	*	simMatrix[0]: [0, 0.644709229603982, 0.41076734188039493, 0.20185418833198668, 
	*					0.18053564755757986, 0.42409442817103027, 0.6005851074860239]
	*
	*	after calling sortWithIndeces(simMatrix[0]), simMatrix[0] is now ordered: 
	*				[0, 0.18053564755757986, 0.20185418833198668, 0.41076734188039493, 
	*					0.42409442817103027, 0.6005851074860239, 0.644709229603982]
	*
	*	simMatrix[0].sortIndices is [0, 4, 3, 2, 5, 6, 1] 
	*	meaning that the files in listFiles[4] is the most similar (other than the files itself), 
	*/
	
	for(var i=0; i&lt;size; i++) {
		//console.log(&quot;NEW LOOP:&quot; + i)
		//console.log(simMatrix[i]);
		sortWithIndeces(simMatrix[i]);
		//console.log(simMatrix[i]);
		console.log(simMatrix[i].sortIndices);
	}
	
	//Now save simMatrix into a file:
	//CAN&#x27;T DO WITH JAVASCRIPT
	
}

function sortWithIndeces(toSort) {
	//code taken from http://stackoverflow.com/questions/3730510/javascript-sort-array-and-return-an-array-of-indicies-that-indicates-the-positi
	for (var i = 0; i &lt; toSort.length; i++) {
		toSort[i] = [toSort[i], i];
	}
	
	toSort.sort(function(left, right) {
		return left[0] &lt; right[0] ? -1 : 1;
	});
	
	toSort.sortIndices = [];
	for (var j = 0; j &lt; toSort.length; j++) {
		toSort.sortIndices.push(toSort[j][1]);
		toSort[j] = toSort[j][0];
	}
	return toSort;
}

function euclideanDistance(v1, v2) {

	return Math.sqrt( ((v1[0]-v2[0])*(v1[0]-v2[0])) 
		+  ((v1[1]-v2[1])*(v1[1]-v2[1])) 
		+  ((v1[2]-v2[2])*(v1[2]-v2[2])) );
	
}

function init() {

	window.addEventListener(&#x27;resize&#x27;, onResize, false);


	


	scene = new THREE.Scene();
	
	aspectRatio = window.innerWidth / window.innerHeight;
	
	camera = new THREE.PerspectiveCamera(45, aspectRatio, 1, 10000);
	camera.useQuaternion = true;
	camera.position.set(0,0,30);
	//Can possibly delete camera.lookAt(scene.position);
	camera.lookAt(scene.position);
	
	renderer = new THREE.WebGLRenderer({antialias:true});
	renderer.setClearColor(0xE6B88A);
	renderer.setSize(window.innerWidth, window.innerHeight);

	element = document.getElementById(&#x27;viewport&#x27;);
	element.appendChild(renderer.domElement);
	
	//lighting
	ambient = new THREE.AmbientLight(0x222222);
	scene.add(ambient);

	point = new THREE.DirectionalLight( 0xffffff, 1, 0, Math.PI, 1 );
	point.position.set( -250, 250, 150 );
	scene.add(point);
	
	stats = new Stats();
	stats.domElement.style.position = &#x27;absolute&#x27;;
	stats.domElement.style.left = &#x27;0px&#x27;;
	stats.domElement.style.top = &#x27;0px&#x27;;
	document.body.appendChild( stats.domElement );

	leftObj = new THREE.Object3D();
	rightObj = new THREE.Object3D();
	leftTransObj = new THREE.Object3D();
	rightTransObj = new THREE.Object3D();
	
	leftTransObj.position = camera.position;
	rightTransObj.position = camera.position;

	//Init the labels as objects so we can make them invisble when a new folder is loaded
	leftLabel = new THREE.Object3D();
	rightLabel = new THREE.Object3D();
	

}


function initOculus() {
	bodyAngle = 0;
	bodyAxis = new THREE.Vector3(0, 1, 0);
	quat = new THREE.Quaternion();
	xzVector = new THREE.Vector3(0, 0, 1);
	
	oculusBridge = new OculusBridge({
		&quot;debug&quot; : true,
		&quot;onOrientationUpdate&quot; : bridgeOrientationUpdated,
		&quot;onConfigUpdate&quot;      : bridgeConfigUpdated
	});
	oculusBridge.connect();

	riftCam = new THREE.OculusRiftEffect(renderer);
	//onResize();
}


function onResize() {
    riftCam.setSize(window.innerWidth, window.innerHeight);
}


function bridgeConfigUpdated(config){
	//Code adapted from OculusBridge examples: https://github.com/Instrument/oculus-bridge
	console.log(&quot;Oculus config updated.&quot;);
	riftCam.setHMD(config);      
}


function bridgeOrientationUpdated(quatValues) {
	//Code adapted from OculusBridge examples: https://github.com/Instrument/oculus-bridge


	// make a quaternion for the the body angle rotated about the Y axis.
	quat.setFromAxisAngle(bodyAxis, bodyAngle);

	// make a quaternion for the current orientation of the Rift
	quatCam = new THREE.Quaternion(quatValues.x, quatValues.y, quatValues.z, quatValues.w);

	// multiply the body rotation by the Rift rotation.
	quat.multiply(quatCam);


	// Make a vector pointing along the Z axis and rotate it accoring to the combined look/body angle.
	xzVector.applyQuaternion(quat);

	// Compute the X/Z angle based on the combined look/body angle.  This will be used for FPS style movement controls
	// so you can steer with a combination of the keyboard and by moving your head.
	viewAngle = Math.atan2(xzVector.z, xzVector.x) + Math.PI;

	// Apply the combined look/body angle to the camera.
	camera.quaternion.copy(quat);
}



/*
function render() { 
	//try{
		riftCam.render(scene, camera);
	/*} catch(e){
		console.log(e);
	if(e.name == &quot;SecurityError&quot;){
		crashSecurity(e);
	} else {
		crashOther(e);
	}
		return false;
	}
	return true;
}/*


/*
function crashSecurity(e){
	oculusBridge.disconnect();
	document.getElementById(&quot;viewport&quot;).style.display = &quot;none&quot;;
	document.getElementById(&quot;security_error&quot;).style.display = &quot;block&quot;;
}

function crashOther(e){
	oculusBridge.disconnect();
	document.getElementById(&quot;viewport&quot;).style.display = &quot;none&quot;;
	document.getElementById(&quot;generic_error&quot;).style.display = &quot;block&quot;;
	document.getElementById(&quot;exception_message&quot;).innerHTML = e.message;
}
*/


function rotateAroundWorldAxis(object, axis, radians) {
	//adapted from http://stackoverflow.com/questions/11060734/how-to-rotate-a-3d-object-on-axis-three-js
	rotWorldMatrix = new THREE.Matrix4();
	rotWorldMatrix.makeRotationAxis(axis.normalize(), radians);
	rotWorldMatrix.multiply(object.matrix);        // pre-multiply
	object.matrix = rotWorldMatrix;	
	//OR object.rotation.setFromRotationMatrix(object.matrix);
	object.rotation.setFromRotationMatrix(object.matrix);

}


function avgPos(data, numberOfAtoms) {
	var position = new THREE.Vector3;
	var sumX=0, sumY=0, sumZ=0;
	for (var i = 0; i &lt; numberOfAtoms; i++) {
			sumX += data[i][1];
			sumY += data[i][2];
			sumZ += data[i][3];
	}
	position.x = sumX/numberOfAtoms;
	position.y = sumY/numberOfAtoms;
	position.z = sumZ/numberOfAtoms;
	
	return position;
}


function drawMolecule(atoms, numberOfAtoms, atomCenter, molObj) {
	//THREE.SphereGeometry(radius, wSegments, hSegments)
	var geometry = new THREE.SphereGeometry(1, 7, 7);
	
	var meshArr = [];
	
	var cylArray = [];
	var tempMesh;
	
	for (var i = 0; i &lt; numberOfAtoms; i++) {
		switch(atoms[i][0]) {
			case &quot;H&quot;:
				tempMesh = new THREE.Mesh(geometry, hydrogenMat);
				tempMesh.position.set(atoms[i][1]-atomCenter.x, atoms[i][2]-atomCenter.y, atoms[i][3]-atomCenter.z);
				molObj.add(tempMesh);
				break;
			case &quot;HO&quot;:
				tempMesh = new THREE.Mesh(geometry, oxygenMat );
				tempMesh.position.set(atoms[i][1]-atomCenter.x, atoms[i][2]-atomCenter.y, atoms[i][3]-atomCenter.z);
				molObj.add(tempMesh);
				break;
			case &quot;O&quot;:
				tempMesh = new THREE.Mesh(geometry, water_oxygenMat );
				tempMesh.position.set(atoms[i][1]-atomCenter.x, atoms[i][2]-atomCenter.y, atoms[i][3]-atomCenter.z);
				molObj.add(tempMesh);
				break;
			case &quot;C&quot;:
				cylArray.push(i)
				break;
			default:
				tempMesh = new THREE.Mesh(geometry, defaultMat );
				tempMesh.position.set(atoms[i][1]-atomCenter.x, atoms[i][2]-atomCenter.y, atoms[i][3]-atomCenter.z);
				molObj.add(tempMesh);
				break;
		}
		
		//change the postion of the atoms relative to the origin
		//meshArr[i].position = new THREE.Vector3(atoms[i][1]-atomCenter.x, atoms[i][2]-atomCenter.y, atoms[i][3]-atomCenter.z);
		//molObj.add(meshArr[i]);
	}
	//Now add in the carbon chains
	
	for(var i=0; i&lt; cylArray.length-1; i++) { 
	
		//get a THREE.Vector3 based on the values in cylArray
		if(cylArray[i] == cylArray[i+1]-1) {
			var pos1 = new THREE.Vector3(atoms[cylArray[i]][1]-atomCenter.x, atoms[cylArray[i]][2]-atomCenter.y, atoms[cylArray[i]][3]-atomCenter.z);
			var pos2 = new THREE.Vector3(atoms[cylArray[i+1]][1]-atomCenter.x, atoms[cylArray[i+1]][2]-atomCenter.y, atoms[cylArray[i+1]][3]-atomCenter.z);
			molObj.add(cylinderBetweenPoints(pos1, pos2));
		}
	}
	
	scene.add(molObj);
}


function cylinderBetweenPoints(vstart, vend) {

	var HALF_PI = Math.PI * .5;
    var distance = vstart.distanceTo(vend);
    var position  = vend.clone().add(vstart).divideScalar(2);

	//avg_cylinder_len += distance;

    var cylinder = new THREE.CylinderGeometry(0.1, 0.1, distance, 8, 1, false);

    var orientation = new THREE.Matrix4();		//a new orientation matrix to offset pivot
    var offsetRotation = new THREE.Matrix4();	//a matrix to fix pivot rotation
    var offsetPosition = new THREE.Matrix4();	//a matrix to fix pivot position
    orientation.lookAt(vstart,vend,new THREE.Vector3(0,1,0));	//look at destination
    offsetRotation.makeRotationX(HALF_PI);		//rotate 90 degs on X
    orientation.multiply(offsetRotation);		//combine orientation with rotation transformations

	var mesh = new THREE.Mesh(cylinder,carbon_cylinderMat);

	// rotate and move the cylinder in position
	mesh.applyMatrix(orientation);
    mesh.position = position;
	
	// add cylinder to the cylinder array and return the mesh
	//cylinder_arr.push(mesh);
    return mesh;
}


function removeObjects() {
	//deletes rightObj, leftObj,  rightTransObj, leftTransObj and all their children
	/*var obj, i;
	for ( i = scene.children.length - 1; i &gt;= 0 ; i -- ) {
	    obj = scene.children[ i ];
	    if ( obj !== ambient &amp;&amp; obj !== camera &amp;&amp; obj !== point &amp;&amp; obj !== handError ) {
	        scene.remove(obj);
	    }
	}*/

	rightLabel.visible = false;
	leftLabel.visible = false;

	//scene.remove(rightLabel);
	//scene.remove(leftLabel);

	var i, obj;

	for ( i = rightObj.children.length - 1; i &gt;= 0 ; i -- ) {
		obj = rightObj.children[ i ];
			rightObj.remove(obj);
	}
	for ( i = leftObj.children.length - 1; i &gt;= 0 ; i -- ) {
		obj = leftObj.children[ i ];
			leftObj.remove(obj);
	}
	
	//rightLabel.position.set(100,100,100);
	//leftLabel.position.set(100,100,100);
	
	//rightLabel.remove(rightLabel.children[0]);

	scene.remove(rightTransObj);
	scene.remove(leftTransObj);
	scene.remove(leftObj);
	scene.remove(rightObj);
	
}

function parseDataToAtoms(data, object) {
	var numberOfAtoms = parseInt(data[1]);
		
	// create the array to hold the parsed data
	//console.log(numberOfAtoms);
	var atoms = new Array(numberOfAtoms);
	
	//Each element in parsed[] is an array of 4 
	for (var i = 0; i &lt; numberOfAtoms; i++) {
		atoms[i] = new Array(4);
		//now atoms is a two dimensional array
	}

	for (var i = 0; i &lt; numberOfAtoms; i++) {
		var next = i+2; // skip COM and number of points in file
		var line = data[next].split(&quot; &quot;);
		for (var j in line) {
			if(j==0)
				atoms[i][j] = line[j];
			else
				atoms[i][j] = parseFloat(line[j]);
		}
	}
	
	var atomCenter = avgPos(atoms, numberOfAtoms);
	drawMolecule(atoms, numberOfAtoms, atomCenter, object);
	
}


function drawObject(filename, object, isLeft){
//loads an object with the corresponding filename to the object

	//Delete the object and all of its children
	var obj, canvas = null, texture = null;
	if(object.children.length &gt; 1) { //or 0?
		for (var i = object.children.length - 1; i &gt;= 0 ; i -- ) {
			obj = object.children[ i ];
				object.remove(obj);
		}
	}

//currently assuming the object is the right object
//this.object = new THREE.Object3D();

//open the file:
	var get = $.get(filename, function(data) {
		// split the data by line
		objRawData = data.split(&quot;\n&quot;);
	});

	get.success(function() {
		//draw the molecules
		parseDataToAtoms(objRawData, object);
		
	if(isLeft) {
		object.position = new THREE.Vector3(-10,0,-camera.position.z);
		leftTransObj.add(object);

	}
	else {
		object.position = new THREE.Vector3(10,0,-camera.position.z);
		rightTransObj.add(object);

	}

	//console.log(leftTransObj.rotation.order);
	//leftOrigRotation = leftTransObj.rotation.clone();
	//rightOrigRotation = rightTransObj.rotation.clone();

	});
}

function draw() {
	
	console.log(&quot;fileName1_draw: &quot; + fileName1);
	console.log(&quot;fileName2_draw: &quot; + fileName2);

	drawObject(fileName1, leftObj, true);
	drawObject(fileName2, rightObj, false);
	
}



function initErrors() {
	var handsGeo = new THREE.PlaneGeometry( 0.75/1.5, 0.375/1.5 );
	//var material = new THREE.MeshBasicMaterial( {color: 0xffff00, side: THREE.DoubleSide} );
	var handsTexture = THREE.ImageUtils.loadTexture(&#x27;textures/nohands.gif&#x27;);
	var handsMat = new THREE.MeshBasicMaterial({map: handsTexture});
	handError = new THREE.Mesh(handsGeo, handsMat);
	handError.position.set(0, -0.2, -0.5);
	scene.add(handError);
	
	/*
	var leapGeo = new THREE.PlaneGeometry( 0.75/1.5, 0.375/1.5 );
	var leapTexture = THREE.ImageUtils.loadTexture(&#x27;textures/noleap.png&#x27;);
	var leapMat = new THREE.MeshBasicMaterial({map: leapTexture});
	leapError = new THREE.Mesh(leapGeo, leapMat);
	leapError.position.set(0, 0, -0.5);
	scene.add(leapError);
	
	camera.add(leapError);
	*/

	camera.add(handError);
	
	scene.add( camera );	
}


function drawLabels(posL, posR, total, filenameLeft, filenameRight, handCalled ){


	leftLabel = createTextMaterial(posL, total, filenameLeft, &quot;left&quot;, handCalled);
	rightLabel = createTextMaterial(posR, total, filenameRight, &quot;right&quot;, handCalled);
	//createTextMaterial(rightLabel);

	//var handsMat = new THREE.MeshBasicMaterial( { color: &quot;red&quot; } );
	//leftLabel = new THREE.Mesh(labelGeo, handsMat);
	
	leftLabel.position.set(-0.2, 0.25, -0.5);
	leftLabel.lookAt(new THREE.Vector3(0,0,1) );
	scene.add(leftLabel);
	camera.add(leftLabel);

	rightLabel.position.set(0.2, 0.25, -0.5);
	rightLabel.lookAt(new THREE.Vector3(0,0,1) );
	scene.add(rightLabel);
	camera.add(rightLabel);

	/*clearTimeout(interval);
	interval  = setTimeout(function(){
		leftLabel.visible = false;
		rightLabel.visible = false;
	}, 5000);*/
}



function createTextCanvas(pos, total, filename, leftOrRight, handCalled) {

	var position = &quot;&quot;;
	var canvas = document.createElement(&#x27;canvas&#x27;);
	var g = canvas.getContext(&#x27;2d&#x27;);
	canvas.width = 100;
	canvas.height = 100;
	g.font = &#x27;Bold 27px Arial&#x27;;

	console.log(leftOrRight)
	if(handCalled == leftOrRight)
		position = &quot; &quot;+ pos + &quot;/&quot; + total;

	g.fillStyle = &#x27;white&#x27;;
	g.fillText(position ,0,40);
	g.strokeStyle=&#x27;black&#x27;;
	g.strokeText(position ,0,40);

	
	g.fillText(&quot;  &quot;+filename.split(&quot;/&quot;).pop() ,0,80);
	g.strokeText(&quot;  &quot;+filename.split(&quot;/&quot;).pop() ,0,80);
	//g.fillText(&quot;  &quot;+filename ,0,80);
	//g.strokeText(&quot;  &quot;+filename ,0,80);

	return canvas;

}

function createTextMaterial(pos, total, filename, leftOrRight, handCalled) {

	//applies the text to the geometry
	console.log(filename);
	var canvas = createTextCanvas(pos, total, filename, leftOrRight, handCalled);
	var texture = new THREE.Texture(canvas);
	var labelGeo = new THREE.PlaneGeometry( 0.75/3, 0.375/3 );
	texture.needsUpdate = true;
	var material = new THREE.MeshBasicMaterial({
		map : texture,
		color : &quot;gray&quot;,
		//transparent : true
	});
	
	return new THREE.Mesh(labelGeo, material);

}


function initLeap() {
	leapController = new Leap.Controller();
	leapController.connect();
}



function render() { 

	frame = leapController.frame();
	if (frame.valid &amp;&amp; frame.hands.length == 2) {

		if(handError.visible)
			camera.remove(handError);
	
		if(frame.hands[0].palmPosition[0] &lt; frame.hands[1].palmPosition[0]) {
			//hands[0] is to the left of hands[1]
			rightHand = frame.hands[1];
			leftHand = frame.hands[0];
		}
		else {
			rightHand = frame.hands[0];
			leftHand = frame.hands[1];
		}
		  
		vRight = rightHand.palmVelocity;
		vLeft = leftHand.palmVelocity;
		//console.log(rightObj.position.z);
		switch(rightHand.pointables.length) {
			case 1:
				rotateAroundWorldAxis(rightTransObj, yAxis,  (-vRight[0]/50)* Math.PI/180);
				rotateAroundWorldAxis(rightTransObj, xAxis,  (vRight[1]/50)* Math.PI/180);
				break;
			case 3:

				if(rightObj.position.z &lt; 25)
					rightObj.translateOnAxis(rightObj.worldToLocal(new THREE.Vector3(0,0,25)), vRight[2]/5000);
				if(rightObj.position.z &lt; -150 ) {
					
					if(lastHand == &quot;left&quot;) {
						simMatrixRow = getIndex(listFiles[simMatrix[simMatrixRow].sortIndices[simMatrixCol]]);
						simMatrixCol = 0;
					}
					lastHand = &quot;right&quot;;

					simMatrixCol += 1;
					if(simMatrixCol == listFiles.length) 
						simMatrixCol = 1;

					fileName2 = prefix + listFiles[simMatrix[simMatrixRow].sortIndices[simMatrixCol]];
					console.log(&quot;filename1 &quot; + fileName1);
					console.log(&quot;filename2 &quot; + fileName2);
					drawObject(fileName2, rightObj, false);

					rightLabel.visible = false;
					leftLabel.visible = false;
					drawLabels(simMatrixRow, 1010, listFiles.length-1 ,fileName1, fileName2, &quot;right&quot;);
				}

				break;
			default:
				rotateAroundWorldAxis(rightObj, yAxis,  (vRight[0]/50)* Math.PI/180);
				rotateAroundWorldAxis(rightObj, xAxis,  (-vRight[1]/50)* Math.PI/180);
				break;
		}
		
		switch(leftHand.pointables.length) {
			case 1:
				rotateAroundWorldAxis(leftTransObj, yAxis,  (-vLeft[0]/50)* Math.PI/180);
				rotateAroundWorldAxis(leftTransObj, xAxis,  (vLeft[1]/50)* Math.PI/180);
				break;
			case 3:
				if(leftObj.position.z &lt; 25)
					leftObj.translateOnAxis(leftObj.worldToLocal(new THREE.Vector3(0,0,25)), vLeft[2]/5000);
				if(leftObj.position.z &lt; -150 ) {
					
					if(lastHand == &quot;right&quot;) {
						simMatrixRow = getIndex(listFiles[simMatrix[simMatrixRow].sortIndices[simMatrixCol]]);
						simMatrixCol = 0;
					}
					lastHand = &quot;left&quot;;

					simMatrixCol += 1;
					if(simMatrixCol == listFiles.length) 
						simMatrixCol = 1;

					fileName1 = prefix + listFiles[simMatrix[simMatrixRow].sortIndices[simMatrixCol]];
					console.log(&quot;filename1 &quot; + fileName1);
					console.log(&quot;filename2 &quot; + fileName2);
					drawObject(fileName1, leftObj, true);

					rightLabel.visible = false;
					leftLabel.visible = false;
					drawLabels(1010, simMatrixRow, listFiles.length-1 ,fileName1, fileName2, &quot;left&quot;);
					
				}

				break;
			default:
				rotateAroundWorldAxis(leftObj, yAxis,  (vLeft[0]/50)* Math.PI/180);
				rotateAroundWorldAxis(leftObj, xAxis,  (-vLeft[1]/50)* Math.PI/180);
				break;
		}

	}
	
	else {
		if(!handError.visble)
			camera.add(handError);
	} 
	riftCam.render(scene, camera);
}



function getIndex(string) {
	for(var i=0; i&lt;listFiles.length; i++) {
		if(listFiles[i] == string)
			return i;
	}
	//will break the code
	return -1;

}


function animate() {

	requestAnimationFrame( animate );

	render();
	stats.update();
}


function leapLoop() {
	
	var vRight, vLeft;
	scene.add(leftTransObj);
	scene.add(rightTransObj);
	
	leftTransObj.add(leftObj);
	rightTransObj.add(rightObj);
	//drawLabels does not work
	//drawLabels(0, 0, listFiles.length-1 ,fileName1, fileName2);
	//Delete bottom if performance hit
	onResize();
	
	animate();

}
	


    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
